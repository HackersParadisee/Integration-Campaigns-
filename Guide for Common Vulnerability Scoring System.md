
---
CVSS scores are needed because organizations face thousands of vulnerabilities across their systems, and not all of them can be fixed at once. Without a standardized system, one team might call a bug `critical` while another calls it `low` which leads to confusion and wasted effort. CVSS solves this by giving each vulnerability a numeric score between 0.0 and 10.0 that consistently reflects its severity. This ensures everyone from developers to CISOs speaks the same language when discussing risk.

Imagine Deloitte is auditing a retail company. Their scanner finds 700 vulnerabilities across web applications, servers, and databases. The development team is already overloaded, so they need a way to decide what to patch first. Here CVSS comes into play. A remote code execution flaw in the payment system receives a CVSS `score of 9.8`, marking it as critical. That means it must be patched immediately because attackers could exploit it to steal credit card data. On the other hand, a missing security header in an internal HR portal is `scored 4.3`, which is only medium. The team schedules it for the next maintenance cycle instead of treating it as an emergency. CVSS helps them focus energy where it matters most.

CVSS is also important for communication. When a penetration tester reports `SQL Injection with Boolean-based payloads` a business manager might not grasp the urgency. But if the tester explains that the vulnerability `scores 9.1` on the CVSS scale, the manager immediately understands it is high risk and could lead to major data loss. This bridges the gap between technical detail and business decision-making.

---
# CVSS Calculator 
A CVSS calculator is an online or offline tool that helps you compute the CVSS score of a vulnerability based on its characteristics. Instead of doing the math manually with formulas, the calculator gives you a simple form with dropdowns (Attack Vector, Privileges Required, Confidentiality Impact, etc). You select the values according to the vulnerability, and the tool automatically computes the **Base Score**, and optionally the **Temporal** and **Environmental scores**.

A **CVSS calculator** is simply a tool that helps security teams measure how serious a vulnerability is. Instead of doing long mathematical formulas, you just answer a few guided questions about the vulnerability. For example:

- Can the attack be done over the internet or does it need physical access?
    
- Does the attacker need a valid login, or can anyone exploit it?
    
- Will the attack expose sensitive data, change information, or crash the system?

Once you fill in these answers, the calculator automatically gives you a **score between 0 and 10**. That score tells you whether the vulnerability is Low, Medium, High, or Critical.

```r
Imagine Deloitte is testing a shopping website. A tester finds that anyone can see other customers’ invoices just by changing the order number in the URL. The tester opens the CVSS calculator and answers:

- Attack is possible from the internet (Network).
    
- No special skill needed (Low complexity).
    
- No login needed (Privileges: None).
    
- No user interaction needed (Interaction: None).
    
- Confidential data is exposed (High impact). 

The calculator gives a score of 9.1 Critical. Instead of just saying “this bug is serious, the tester can now present a clear, standardized risk rating that both developers and managers understand.
```

---

<img width="1277" height="622" alt="Pasted image 20250907123840" src="https://github.com/user-attachments/assets/e4e872dc-9035-4982-ae70-e848cd870f00" />


1. `Attack Vector`
- ==(AV → Network)== Attack Vector tells you how far away an attacker can be when exploiting the vulnerability. In this SQL Injection example, the attack happens through a public web application, so the attacker can launch it over the internet from anywhere in the world. That makes it **Network level**. If instead the bug required being inside the company’s Wi-Fi or plugging a USB into the server, the score would drop, because not every attacker has that physical or local access. Choosing Network means the attack is **globally exploitable with no barriers**, which is why it heavily increases the severity.
- ==(AV → Physical)== The attacker must physically touch or interact with the vulnerable device to exploit it. This is the hardest attack vector because it requires the attacker to be in the same location as the target system.
-  ==(AV → Local)== The attacker must already have local access to the target system or be able to execute code locally.  This means they cannot exploit the issue remotely. Instead, they either need a valid login account, or trick a user into running malicious code. In short the attacker must have low privileged  user access on that system or credentials of that low privileged user.
-  ==(AV → Adjacent)== The attacker must be on the same **network segment** (subnet, Wi-Fi, or Bluetooth range) as the victim. They cannot attack over the global internet, but once they are nearby (LAN or same hotspot), they can exploit.

2. `Attack Complexity (AC → Low / high )`
Attack Complexity measures how much “*special setup*” or rare conditions are needed to exploit the vulnerability. For this SQL Injection, the attacker simply sends malicious input like `' OR 1=1--` into the login form and instantly bypasses authentication. No race conditions, no timing issues, no insider access are needed. Because exploitation works **reliably and predictably**, the complexity is **Low**. If the attack required guessing a one-time token within seconds or chaining multiple bugs, then it would be **High**. In short, Low complexity means **any attacker can replicate the exploit easily**.

3. `Privileges Required (PR → None, Low, High)`
This metric looks at whether the attacker needs an account or special permissions before launching the exploit. In our case, the SQL Injection is on the login page itself, meaning the attacker doesn’t even need to register or log in. That’s why Privileges Required is **None**. If the bug existed only after login, PR would be **Low** or **High** depending on the role. The lower the privilege needed, the more dangerous the bug, since anyone can attempt it. For Deloitte’s clients, vulnerabilities with `PR=None` usually demand urgent attention because they can be exploited by **anonymous internet users**.

4. `User Interaction (UI → None, Required)`
This checks if a victim user must perform an action, like clicking a link or opening a file, before the attack works. SQL Injection happens directly against the server. The attacker doesn’t need to trick a user into anything. They send crafted input, and the database responds. That’s why User Interaction is **None**. Compare this with phishing or malicious PDF exploits, where the victim must cooperate unknowingly. Vulnerabilities with `UI=None` are always more severe, because the attacker can operate **fully independently**.

5. `Scope (S → Unchanged, Changed )`
Scope asks whether exploiting the vulnerability lets the attacker move beyond the affected system into other systems or domains. In this case, SQL Injection only impacts the application and its database. It does not directly allow compromise of unrelated systems like the underlying OS or third-party services. That makes the scope **`Unchanged`**. If the bug allowed breaking out of the app into the server OS (for example, through command injection that lets you run system commands), the scope would be **`Changed`**, which would increase the severity. Scope unchanged means **`damage is contained within the same boundary`** even if it’s still critical.

6.  `Confidentiality (C → High, Medium, Low)`
Confidentiality looks at whether sensitive information is exposed. SQL Injection is one of the most direct data theft tools. An attacker can dump entire customer databases, including names, addresses, credit card numbers, or passwords. That’s why Confidentiality impact is **High**. If the injection only revealed a small error message without exposing records, it would be **Low**. High confidentiality impact means **serious privacy or regulatory violations** like GDPR or PCI DSS breaches.

7. `Integrity (I → High , Medium, Low)`
Integrity measures the ability of an attacker to change or corrupt data. With SQL Injection, attackers don’t just read data—they can also insert, update, or delete records. For example, an attacker could change account balances or erase audit logs. This completely undermines the trustworthiness of the system. That makes Integrity impact **High**. In comparison, if the vulnerability only allowed reading without modifying, Integrity would be **None**. High integrity damage means **attackers can rewrite reality inside the database**.

8. `Availability (A → Low, High , Medium)`
Availability checks whether the attack disrupts the system’s operations. SQL Injection is not primarily a denial-of-service attack, but it can still degrade availability. For example, attackers could craft queries that lock the database, overload it with complex joins, or delete entire tables. This could slow down or crash the service temporarily. However, because availability is not fully destroyed in most exploitation cases, the impact is **Low** rather than High. A vulnerability that directly crashes the system or wipes out resources would rank higher. Here, Availability is a **side effect**, not the main weapon.

---
# Practical 

- NVD - https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator
- FIRST - https://www.first.org/cvss/calculator/3-1

<img width="1524" height="628" alt="Pasted image 20250907124120" src="https://github.com/user-attachments/assets/81c66c29-4ac1-4a9a-b32d-487c9bc0d8d9" />


| Metric                   | Values and Meaning                                                                                                                                        |
| ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Attack Vector (AV)       | N : Network (remote exploit) <br>A : Adjacent (same LAN/Wi-Fi/Bluetooth) <br>L : Local (requires local access) <br>P : Physical (requires physical touch) |
| Attack Complexity (AC)   | L : Low (easy, no conditions) <br>H : High (needs timing or special setup)                                                                                |
| Privileges Required (PR) | N : None (no account needed) <br>L : Low (basic user access) <br>H : High (admin/root)                                                                    |
| User Interaction (UI)    | N : None (no victim action) <br>R : Required (victim must click/open/execute)                                                                             |
| Scope (S)                | U : Unchanged (same component affected) <br>C : Changed (other components affected)                                                                       |
| Confidentiality (C)      | N : None <br>L : Low (partial data) <br>H : High (full data disclosure)                                                                                   |
| Integrity (I)            | N : None <br>L : Low (some changes) <br>H : High (full modification)                                                                                      |
| Availability (A)         | N: None <br>L : Low (reduced performance/limited downtime)  <br>H : High (complete DoS)                                                                   |

---


